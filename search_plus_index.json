{"./":{"url":"./","title":"简介","keywords":"","body":"简介 RFB RFB(Remote Framebuffer Protocol) 远程帧缓冲协议，是一种允许用户通过网络连接控制远端计算机的七层网络协议。在 RFB 协议中，用户通过本地鼠标、键盘输入，经由远端计算机计算后，将图形用户界面（GUI）回传本地进行输出。 Framebuffer TODO VNC 软件 VNC (Vitual Network Computing) 是通过 RFB 协议实现屏幕画面分享和远程操作的应用软件，是 RFB 协议的具体应用，是远程桌面软件的一种。VNC 和 RFB 的关系类似 Chrome 和 HTTP，RFB 和 HTTP 是协议，VNC 和 Chrome 是具体实现。 协议特点 RFB 协议有以下几个特点，这些设计理念贯穿协议 瘦客户端。客户端职责约简单清晰越好，无状态设计 基于弱网络环境传输 跨操作系统、跨语言兼容性 RFB 协议版本 RFB 协议有三个公开版本，分别是 3.3、3.7和3.8，3.8 是稳定版本。 版本 发布时间 协议差异 Version 3.3 1998-01 服务器单向认证 Version 3.7 2003-8-12 关闭连接时返回原因 Version 3.8 (Final) 2010-11-26 - 三个版本只在协议的握手阶段和初始化阶段存在差异，在数据流交换阶段保持一致。 RFB 协议的拓展 第三方 VNC 服务端和客户端拓展了 3.8 版本协议，提供更多的认证方式，优化传输效率。 Tight RealVNC Ultra VMWare RFB 的发展历史 2002 年，AT&T 关闭其位于英国剑桥的 Olivetti 研究实验室。 2002 年，VNC 技术发明者 Tristan Richardson 合伙成立 RealVNC 公司，向商业公司提供企业级远程访问软件。 2003年8月12日，Richardson 公开 RFB 协议的 3.7 版本。 2010年11月26日，发布稳定协议版本 v3.8。 RFB 是 IETF 公开的开源通信协议，但 RFB® 和 VNC® 是 RealVNC 公司的注册商标。 "},"initial/":{"url":"initial/","title":"协议初始化","keywords":"","body":"初始化 RFB 协议初始化有三个阶段，分别是协议版本握手、认证、初始化。 "},"initial/protocol-version.html":{"url":"initial/protocol-version.html","title":"协议版本握手","keywords":"","body":"协议版本握手 握手就客户端和服务端使用的协议版本达成共识。 握手过程 建立连接后，服务器首先向客户端发送版本 X，收到 X 后，客户端向服务器发送不高于 X 的版本 Y。 X/Y 有三个公开可选版本 3.3/3.7/3.8，部分客户端或浏览器变种可能会发送其他的协议版本，统一将非标协议认定为 3.3（协议认为未公开协议版本没有实现3.7/3.8 中引入的特殊握手流程）。 sequenceDiagram participant Client participant Server Server->>Client: ProtocolVersion Client->>Server: ProtocolVersion 协议报文 协议消息由标识符、主次版本组成，其结构体如下： +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 3 | U8 array | protocol | | 1 | U8 [32] | blank | | 3 | U8 array | major version| | 1 | U8 [42] | pot | | 3 | U8 array | minor version| +--------------+--------------+--------------+ 对于 3.8 版本协议，其发送协议头部如下： RFB 003.008\\n (hex 52 46 42 20 30 30 33 2e 30 30 38 0a) "},"initial/security-type.html":{"url":"initial/security-type.html","title":"安全握手","keywords":"","body":"安全握手 协商好协议版本后，客户端和服务端进行安全握手，就认证方式达成共识，并完成认证过程。 握手过程 认证的流程图如下： sequenceDiagram participant Client participant Server alt incompatible Server->>Client: SecurityTypes(Empty) Server->>Client: FailReason Server-XClient: Close end Server->>Client: SecurityTypes Client->>Server: SecurityType alt None else VNC Auth Server->>Client: Challenge Client->>Server: ChallengeResponse end Server->>Client: SecurityResult alt failed Server->>Client: FailReason Server-XClient: Close end 服务器向客户端列举支持的加密方式，客户端挑选支持的认证方式，告知服务端。 根据认证方式，完成认证 服务端返回认证结果，完成安全握手 协议报文 security-types +--------------------------+-------------+--------------------------+ | No. of bytes | Type | Description | | | [Value] | | +--------------------------+-------------+--------------------------+ | 1 | U8 | number-of-security-types | | number-of-security-types | U8 array | security-types | +--------------------------+-------------+--------------------------+ number-of-security-types: 认证方式数量 security-types: 认证方式标识符 协议定义的标识符有三种，剩下的由协议厂家进行拓展： +--------+--------------------+ | Number | Name | +--------+--------------------+ | 0 | Invalid | | 1 | None | | 2 | VNC Authentication | +--------+--------------------+ security-type 客户端以单字节报文告知选择的认证方式 +--------------+--------------+---------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+---------------+ | 1 | U8 | security-type | +--------------+--------------+---------------+ security-type: 达成共识的协议标识符 fail-reason 当错误发送时，例如，服务端不兼容客户端版本，服务端会发送空的 SecurityTypes，发送消息说明错误原因后，关闭连接。 FailReason 报文如下： +---------------+--------------+---------------+ | No. of bytes | Type [Value] | Description | +---------------+--------------+---------------+ | 4 | U32 | reason-length | | reason-length | U8 array | reason-string | +---------------+--------------+---------------+ reason-length: 原因长度 reason-string: 错误原因 VNC Auth VNC Auth 过程，服务器首先发送 16 字节的随机字符串，作为 challenge。客户端用密码通过 DES 算法对 challenge 进行加密，将加密后的 16 字节结果告知服务端。 TODO: 加密算法详解 有几点需要注意： 为格式化密钥，密码会被删节/补齐为 8 字符 VNC Auth 是弱加密，不能用于不可信网络 为了更安全访问，可以通过 IPsec/SSH 加密链路 Challenge +--------------+--------------+-------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+-------------+ | 16 | U8 | challenge | +--------------+--------------+-------------+ ChallengeResponse +--------------+--------------+-------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+-------------+ | 16 | U8 | response | +--------------+--------------+-------------+ SecurityResult 客户端选择认证方式后，服务端返回 SecurityResult 告知认证结果，哪怕使用 None 认证。 如果认证失败，服务器发送 failed 和 fail-reason 报文，主动关闭连接。 +--------------+--------------+-------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+-------------+ | 4 | U32 | status: | | | 0 | OK | | | 1 | failed | +--------------+--------------+-------------+ "},"initial/initial.html":{"url":"initial/initial.html","title":"初始化","keywords":"","body":"初始化 收 SecurityResult 后，客户端应当发送 ClientInit 数据包，收到后，服务端发送 ServerInit 包。 sequenceDiagram participant Client participant Server Server->>Client: SecurityResult(success) Client->>Server: ClientInit Server->>Client: ServerInit 客户端初始化 客户端初始化需要声明是否的共享屏幕。 +--------------+--------------+-------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+-------------+ | 1 | U8 | shared-flag | +--------------+--------------+-------------+ shared-flag: 是否与其他客户端共享连接。如果是 1，允许服务端保持/加入其他客户端的连接。如果是0，服务端应该主动断开与其他客户端的连接。 服务端初始化 收到 ClientInit 消息后，服务端发送 ServerInit 消息，声明帧缓冲区大小、像素格式以及桌面的名称。 +--------------+--------------+------------------------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+------------------------------+ | 2 | U16 | framebuffer-width in pixels | | 2 | U16 | framebuffer-height in pixels | | 16 | PIXEL_FORMAT | server-pixel-format | | 4 | U32 | name-length | | name-length | U8 array | name-string | +--------------+--------------+------------------------------+ framebuffer-width in pixels: 屏幕宽度 framebuffer-height in pixels: 屏幕高度 server-pixel-format: 服务器默认像素格式 name-length/name-string: 桌面的名字 如果客户端无法响应服务端制定的 pixel-format，可以主动发起 SetPixelFormat 重新设置。 "},"input/":{"url":"input/","title":"输入协议","keywords":"","body":"输入协议 RFB 协议支持鼠标和键盘两种输入设备，同时支持剪贴板进行远程复制粘贴。 "},"input/mouse.html":{"url":"input/mouse.html","title":"鼠标事件","keywords":"","body":"鼠标事件 鼠标指针即鼠标操作事件，分移动事件和点击事件两种。在 RFB 协议中，使用 PointerEvent 表示客户端触发一次鼠标事件。 协议报文 鼠标事件的报文如下 +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U8 [5] | message-type | | 1 | U8 | button-mask | | 2 | U16 | x-position | | 2 | U16 | y-position | +--------------+--------------+--------------+ message-type: 无符号整形，固定 0x5 button-mask: 8 位掩码，表示键位状态，1为按下，0为弹起 x-position: 当前 X 坐标 y-position: 当前 Y 坐标 button-mask 的 Bit0/1/2 位置分别代表鼠标的左键、中建、右键。使用滚轮的鼠标，每向上滑动一次，会发送一个 Bit3 的按下和弹起事件；每向下滑动一次，会发送一个 Bit4 的按下和弹起事件。 USB/PS/2 鼠标协议 在 PS/2 或 USB 鼠标协议中，有类似 RFB 协议的表达方式。 ┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐ │ │ Bit7 │ Bit6 │ Bit5 │ Bit4 │ Bit3 │ Bit2 │ Bit1 │ Bit0 │ ├──────┼──────┼──────┼──────┼──────┼──────┼──────┼──────┼──────┤ │Byte 1│Y Over│X Over│X Sign│Y Sign│ 0x1 │ Mid │Right │ Left │ ├──────┼──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┤ │Byte 2│ X Movement │ ├──────┼───────────────────────────────────────────────────────┤ │Byte 3│ Y Movement │ ├──────┼───────────────────────────────────────────────────────┤ │Byte 4│ Z Movement │ └──────┴───────────────────────────────────────────────────────┘ 鼠标协议和 RFB 协议有两点不同： 鼠标协议的 Bit0/1/2 和 RFB 协议的 Bit0/2/1 对应 鼠标协议的中轮转动，需要转换为 RFB 协议的按下/弹起事件 根据 wiki 描述，RFB 协议只支持8个鼠标键位，左中右和滑轮占用5个，只有3个键位给特殊按键（例如：多功能游戏鼠标） "},"input/keyboard.html":{"url":"input/keyboard.html","title":"键盘事件","keywords":"","body":"键盘事件 在正常理解中，键盘事件的处理应该是简单明了的。参考以下协议报文 +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U8 [4] | message-type | | 1 | U8 | down-flag | | 2 | | padding | | 4 | U32 | key | +--------------+--------------+--------------+ message-type: 固定为 0x4 down-flag: 1 表示键位按下，0 表示弹起 pending: 对齐字节，方便解析 key: 表示具体的键位 其中 key 的值在 X 系统中有明确定义 +-----------------+--------------------+ | Key name | Keysym value (hex) | +-----------------+--------------------+ | BackSpace | 0xff08 | | Tab | 0xff09 | | Return or Enter | 0xff0d | | Escape | 0xff1b | | Insert | 0xff63 | | Delete | 0xffff | | Home | 0xff50 | | End | 0xff57 | | Page Up | 0xff55 | | Page Down | 0xff56 | | Left | 0xff51 | | Up | 0xff52 | | Right | 0xff53 | | Down | 0xff54 | | F1 | 0xffbe | | F2 | 0xffbf | | F3 | 0xffc0 | | F4 | 0xffc1 | | ... | ... | | F12 | 0xffc9 | | Shift (left) | 0xffe1 | | Shift (right) | 0xffe2 | | Control (left) | 0xffe3 | | Control (right) | 0xffe4 | | Meta (left) | 0xffe7 | | Meta (right) | 0xffe8 | | Alt (left) | 0xffe9 | | Alt (right) | 0xffea | +-----------------+--------------------+ 组合键 组合键指 Ctrl + Alt + Del 或 Shift + 3 等组合按键。受不同的操作系统、键盘布局影响，组合键是按键事件中容易发生歧义的一环。 RFB 基本遵循以下规则： 如果客户端 key 在 keysym 中存在，服务端应该遵循 keysym 的指示，尽可能的忽略客户端传递 Shift、CpasLock 等键位，在需要时，应该主动补充/忽略 Shift 等键位。例如，在 US 键盘布局中，# 需要按下 Shift + 3，但是在 UK 布局中不需要。这就意味着用户在输入 # 的时候不会输入 Shift。这种情况下，服务端应该主动模拟一个 Shift 状态，防止输入的键位是 3。同理，如果 key 输入的键位是 A，服务端统一要模拟一个 Shift，保证输入的是 A 而不是 a。 如果客户端 key 在 keysym 中不存在（例如 Ctrl + A），服务端应该遵循客户端指示，客户端应该主动在 A 前发送 Ctrl 的按键。 如果客户端通过 Ctrl + Alt + Q 来输入 @，客户端应该在发送 Ctrl/Alt/@后，主动发送Ctrl/Alt的弹起事件。 对于 BackTab，常见的有三种实现，ISO_Left_Tab BackTab 和 Shift + Tab。RFB 协议优先使用 Shift + Tab，但对于其他的键位，服务端和客户端应当尽量提供兼容。 优先使用 ASCII 而不是 unicode 对于 Ctrl + Alt + Del 等无法被客户端操作系统拦截的按键（系统拦截有更高优先级），客户端应该提供操作按钮 "},"input/clipboard.html":{"url":"input/clipboard.html","title":"剪贴板","keywords":"","body":"剪贴板 复制粘贴是双向事件，可以由客户端向服务端复制，也可以由服务端向客户端复制。 协议报文 复制剪贴板的报文如下： +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U8 [3/6] | message-type | | 3 | | padding | | 4 | U32 | length | | length | U8 array | text | +--------------+--------------+--------------+ message-type: 消息类型，客户端是 0x6，服务端是 0x3 length: 文本长度 text: 复制粘贴的文本，长度由 length 限制 协议有几点限制 只支持 ISO 8859-1 (Latin-1) 字符集 使用单独换行符 0x0a，不应该使用回车符 0x0d 拓展剪贴板伪协议 Latin-1 字符集极大限制了粘贴板功能，社区一直在寻找在兼容旧协议基础上拓展剪贴板字符集的方法。 2016年，Cendio Ossman 将 Extended Clipboard Pseudo-Encoding 合入协议主分支，目前 UltraVNC/TigerVNC/RealVNC 服务端都支持此拓展协议，x11vnc 尚未提供支持（2021/8/11）。 拓展剪贴板伪协议需要客户端和服务端软件同时支持。报文拓展了 ServerCutText 和 ClientCutText， 如下： +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U8 [3/6] | message-type | | 3 | | padding | | 4 | S32 | length | | 4 | U32 | text-type | | length-4 | U8 array | text | +--------------+--------------+--------------+ length: 数据类型由 U32 改为 S32。首bit是标志位，0 表示传递原始 Latin-1 消息，1 表示传递 unicode。abs(length) 表示消息长度。 text-type: 消息类型，支持文本、富文本、html 等消息类型 text: 消息头部增加4字节，表示复制的消息类型 text-type 值的含义如下 Bit Name Description 0 text UTF-8 编码，以 \\r\\n 为换行 1 rtf 微软富文本格式 2 html 微软 HTML 格式 3 dib Microsoft Device Independent Bitmap 4 files 文件，未实现 5-15 Reserved for future formats 16-23 Reserved 24 caps 指示 text-type 的最大长度 25 request 强制对端传递剪贴板内容 26 peek 强制对端更新支持的 text-type 27 notify peek 回包，返回支持的 text-type 28 provide request 回包，返回粘贴板内容 29-31 Reserved for future actions 增强协议的换行符是 \\r\\n，原始协议的换行符是 \\n "},"display/pixel-format.html":{"url":"display/pixel-format.html","title":"像素格式","keywords":"","body":"像素格式 帧缓冲由二维像素点组成，帧缓冲的长和宽的成绩代表像素点总数，也叫分辨率。 PixelFormat 在 RFB 协议中，使用 16 字节结构体 PIXEL_FORMAT 描述像素格式。 +--------------+--------------+-----------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+-----------------+ | 1 | U8 | bits-per-pixel | | 1 | U8 | depth | | 1 | U8 | big-endian-flag | | 1 | U8 | true-color-flag | | 2 | U16 | red-max | | 2 | U16 | green-max | | 2 | U16 | blue-max | | 1 | U8 | red-shift | | 1 | U8 | green-shift | | 1 | U8 | blue-shift | | 3 | | padding | +--------------+--------------+-----------------+ bits-per-pixel: 描述单个像素的位数，位数越大，色彩越丰富。只支持[8|16|32] depth: 色深，像素中表示色彩的位数 big-endian-flag: 多字节像素的字节序，非零即打断 true-color-flag: 1 表示真彩色，pixel 表示颜色；0 表示调色板，pexel 表示颜色颜色表中的位置 -max/-shift: 获取红蓝绿三色的位移量和长度，max=2^N-1,N是颜色的位数 BigEndian: Blue Shift Green Shift Red Shift │ │ │ ▼ ▼ ▼ ┌──────────────────┬─────────────────┬─────────────────┐ │ BLUE MAX │ GREEN MAX │ RED MAX │ └──────────────────┴─────────────────┴─────────────────┘ bits-per-pixel 必须大于或等于 depth SetPixelFormat 客户端发送 SetPixelFormat，声明支持的像素格式（画面质量）。此消息覆盖 ServerInit 消息中服务端声明的初始化像素格式。 当 true-color-flag 为 0 时，要求服务端发送 SetColorMapEntries，声明使用的颜色表。客户端发送 SetPixelFormat 后，需清空本地缓存的颜色表，无论颜色表中是否有内容。 +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U8 [0] | message-type | | 3 | | padding | | 16 | PIXEL_FORMAT | pixel-format | +--------------+--------------+--------------+ message-type: 消息类型，固定为 0 pixel-format: PixelFormat 结构 "},"display/display.html":{"url":"display/display.html","title":"显示协议","keywords":"","body":"显示协议 客户端可能处于弱网络环境，或只有较低性能的渲染设备。如果服务端不加限制的向客户端发送像素画面，很容易造成客户端卡死或网络堵塞。在 RFB 协议中，当且仅当客户端主动请求显示数据时，服务端才会将 FramebufferUpdate 发往客户端。响应 FramebufferUpdateRequest 往往需要返回多条 FramebufferUpdate。 sequenceDiagram participant Client participant Server Client->>Server: FramebufferUpdateRequest loop no change Client->>Server: FramebufferUpdateRequest end Server->>Client: FramebufferUpdate Server->>Client: FramebufferUpdate Server->>Client: FramebufferUpdate FramebufferUpdateRequest FramebufferUpdateRequest 告知服务端，客户端希望得到指定区域的内容。 +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U8 [3] | message-type | | 1 | U8 | incremental | | 2 | U16 | x-position | | 2 | U16 | y-position | | 2 | U16 | width | | 2 | U16 | height | +--------------+--------------+--------------+ message-type: 消息类型，固定 3 incremental: 是否是增量请求。 x-position/y-position: 区域的起始坐标 width/height: 区域的长度和宽度 incremental 通常为非 0 值，服务器只需要发送变更的图形位置。当客户端丢失了缓存的帧缓冲信息，或者刚建立连接，需要完整的图像信息时，将 incremental 置为 0，获取全量信息。 FramebufferUpdate FramebufferUpdate 由一组色块(rectangles of pixel)组成，用户受到 FramebufferUpdate 后，将消息内的色块填充到帧缓冲对应区域，完成图像展示。 +--------------+--------------+----------------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+----------------------+ | 1 | U8 [0] | message-type | | 1 | | padding | | 2 | U16 | number-of-rectangles | +--------------+--------------+----------------------+ message-type: 消息类型，固定 0 number-of-rectangles: 色块的数量 FramebufferUpdateRectangle FramebufferUpdate 携带 number-of-rectangles 数量的色块信息，每个色块都有头部信息 +--------------+--------------+---------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+---------------+ | 2 | U16 | x-position | | 2 | U16 | y-position | | 2 | U16 | width | | 2 | U16 | height | | 4 | S32 | encoding-type | +--------------+--------------+---------------+ x-position/y-position: 色块起始坐标 width/height: 色块宽度和高度 encoding-type: 编码类型 "},"encoding/":{"url":"encoding/","title":"编码","keywords":"","body":"编码 ”编码“ 是像素数据的表达方式。在发往客户端前，服务器经常将发送的图形数据进行编码、压缩，提高图像传输效率。 +--------+-----------------------------+ | Number | Name | +--------+-----------------------------+ | 0 | Raw | | 1 | CopyRect | | 2 | RRE | | 5 | Hextile | | 15 | TRLE | | 16 | ZRLE | | -239 | Cursor pseudo-encoding | | -223 | DesktopSize pseudo-encoding | +--------+-----------------------------+ Raw: 原始位图编码，即不编码 CopyRect: 从帧缓冲复制 RRE: rise-and-run-length 二维游程编码 Hextile: RRE 的变种，卷积游程编码 TRLE: 镶嵌游程编码 ZRLE: Zlib Run-Length Encoding，zlib 压缩的游程编码 Cursor pseudo-encoding: 鼠标指针伪编码 DesktopSize pseudo-encoding: 桌面分辨率位编码 "},"encoding/raw.html":{"url":"encoding/raw.html","title":"Raw 原始编码","keywords":"","body":"Raw 原始编码 Raw 是最简单也是最原始的编码，直接向客户端传递位图信息，不进行编码优化。 在 Raw 格式中，像素按从左到右，从上到下的顺序排列成一维数组。 协议要求客户端必须支持 Raw 类型编码。 协议要求服务器必须传输 Raw 类型编码，除非客户端另有要求。 +----------------------------+--------------+-------------+ | No. of bytes | Type [Value] | Description | +----------------------------+--------------+-------------+ | width*height*bytesPerPixel | PIXEL array | pixels | +----------------------------+--------------+-------------+ pixels: 像素数组 "}}