{"./":{"url":"./","title":"远程帧缓冲协议","keywords":"","body":"远程帧缓冲协议 RFB RFB (Remote Framebuffer Protocol) 远程帧缓冲协议，是一种允许用户通过网络连接控制远端计算机的七层网络协议。 在 RFB 协议中，用户通过本地鼠标、键盘输入，经由远端计算机计算后，将图形用户界面（GUI）回传本地进行输出。 协议特点 协议设计有以下几个特点： 瘦客户端。客户端职责简单清晰，无状态 考虑弱网络环境 跨操作系统兼容性 协议版本 RFB 协议有三个公开版本，分别是 3.3、3.7和3.8，3.8 是稳定版本。 版本 发布时间 协议差异 Version 3.3 1998-01 服务器单向认证 Version 3.7 2003-8-12 关闭连接时返回原因 Version 3.8 (Final) 2010-11-26 - 三个版本只在协议的握手阶段和初始化阶段存在差异，在数据流交换阶段保持一致。 协议的拓展 第三方 VNC 服务端和客户端拓展了 3.8 版本协议，提供更多的认证方式，优化传输效率。 Tight RealVNC Ultra VMWare RFB 的发展历史 2002 年，AT&T 关闭其位于英国剑桥的 Olivetti 研究实验室。 2002 年，VNC 技术发明者 Tristan Richardson 合伙成立 RealVNC 公司，向商业公司提供企业级远程访问软件。 2003年8月12日，Richardson 公开 RFB 协议的 3.7 版本。 2010年11月26日，发布稳定协议版本 v3.8。 RFB 是 IETF 公开的开源通信协议 RFB® 和 VNC® 是 RealVNC 公司的注册商标。 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"GLOSSORY.html":{"url":"GLOSSORY.html","title":"术语表","keywords":"","body":"帧缓冲 帧缓冲器也称为帧缓冲或者显存，是用来存储渲染数据的地方。帧缓冲的每一个存储单位对应一个像素，它是屏幕显示画面的直接映象，又称为位映射图(Bit Map)。 调色板 传统的帧缓冲器支持的色彩模式很广泛。受限于昂贵的内存，大多数早期的帧缓冲器使用的是1位、2位、4位或 8位的色深。小的色深导致不能产生完整的色彩范围。其解决方法是为帧缓冲器增加一个查找表（lookup table，LUT），把帧缓冲器中存储的每个“颜色”作为一个索引。这就是所谓的索引色（indexed color）模式。 游程编码 游程编码（run-length encoding，RLE）是一种比较简单的压缩算法，其基本思想是将重复且连续出现多次的字符使用（连续出现次数，某个字符）来描述。 举例来说，字符串\"AAAABBBCCDEEEE\"，由4个A、3个B、2个C、1个D、4个E组成，游程编码将其压缩为4A3B2C1D4E，由14个字符转成10个字符，压缩比 71.4%。 游程编码的优点是将重复性高的数据压缩成小单位；若数据出现频率不高，压缩结果可能比原始数据大。例如：\"ABCDE\"，压缩结果为\"1A1B1C1D1E\"，由5个字符转成10个字符，压缩比 200%。 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"handshake/":{"url":"handshake/","title":"握手","keywords":"","body":"握手 RFB 协议有四个阶段： graph LR protocol[\"协议握手\"] auth[\"认证\"] initial[\"初始化\"] transfer(\"数据交互\") subgraph 握手 protocol --> auth auth --> initial end initial --> transfer transfer --> transfer 协议握手：对协议版本达成共识 认证：认证客户端身份 初始化：交换像素格式等背景数据 数据交互：传输交互事件，更新图像帧 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"handshake/protocol-version.html":{"url":"handshake/protocol-version.html","title":"协议版本握手","keywords":"","body":"协议握手 协议握手对客户端和服务端通信过程使用的协议版本达成共识，有可能的情况下，对不同协议版本实现向前兼容。 握手过程 建立 TCP 连接后，服务器首先向客户端发送版本 X，收到 X 后，客户端向服务器发送不高于 X 的版本 Y。 RFB 有三个公开可选版本 3.3/3.7/3.8。 部分客户端或浏览器变种可能会发送其他的协议版本，统一将非标协议认定为 3.3（协议认为未公开协议版本没有实现3.7/3.8 中引入的特殊握手流程）。 sequenceDiagram participant Client participant Server Server->>Client: ProtocolVersion Client->>Server: ProtocolVersion 协议报文 协议消息由标识符、主次版本组成，其结构体如下： +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 3 | U8 array | protocol | | 1 | U8 [32] | blank | | 3 | U8 array | major version| | 1 | U8 [42] | pot | | 3 | U8 array | minor version| +--------------+--------------+--------------+ 对于 3.8 版本协议，其发送协议头部如下： RFB 003.008\\n (hex 52 46 42 20 30 30 33 2e 30 30 38 0a) Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"handshake/security-type.html":{"url":"handshake/security-type.html","title":"安全握手","keywords":"","body":"安全握手 协商好协议版本后，客户端和服务端进行安全握手，就认证方式达成共识，并完成认证过程。 握手过程 认证的流程图如下： sequenceDiagram participant Client participant Server alt incompatible Server->>Client: SecurityTypes(Empty) Server->>Client: FailReason Server-XClient: Close end Server->>Client: SecurityTypes Client->>Server: SecurityType alt None else VNC Auth Server->>Client: Challenge Client->>Server: ChallengeResponse end Server->>Client: SecurityResult alt failed Server->>Client: FailReason Server-XClient: Close end 服务器向客户端列举支持的加密方式，客户端挑选支持的认证方式，告知服务端。 根据认证方式，完成认证 服务端返回认证结果，完成安全握手 协议报文 security-types +--------------------------+-------------+--------------------------+ | No. of bytes | Type | Description | | | [Value] | | +--------------------------+-------------+--------------------------+ | 1 | U8 | number-of-security-types | | number-of-security-types | U8 array | security-types | +--------------------------+-------------+--------------------------+ number-of-security-types: 认证方式数量 security-types: 认证方式标识符 协议定义的标识符有三种，剩下的由协议厂家进行拓展： +--------+--------------------+ | Number | Name | +--------+--------------------+ | 0 | Invalid | | 1 | None | | 2 | VNC Authentication | +--------+--------------------+ security-type 客户端以单字节报文告知选择的认证方式 +--------------+--------------+---------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+---------------+ | 1 | U8 | security-type | +--------------+--------------+---------------+ security-type: 达成共识的协议标识符 fail-reason 当错误发送时，例如，服务端不兼容客户端版本，服务端会发送空的 SecurityTypes，发送消息说明错误原因后，关闭连接。 FailReason 报文如下： +---------------+--------------+---------------+ | No. of bytes | Type [Value] | Description | +---------------+--------------+---------------+ | 4 | U32 | reason-length | | reason-length | U8 array | reason-string | +---------------+--------------+---------------+ reason-length: 原因长度 reason-string: 错误原因 VNC Auth VNC Auth 过程，服务器首先发送 16 字节的随机字符串，作为 challenge。客户端用密码通过 DES 算法对 challenge 进行加密，将加密后的 16 字节结果告知服务端。 TODO: 加密算法详解 有几点需要注意： 为格式化密钥，密码会被删节/补齐为 8 字符 VNC Auth 是弱加密，不能用于不可信网络 为了更安全访问，可以通过 IPsec/SSH 加密链路 Challenge +--------------+--------------+-------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+-------------+ | 16 | U8 | challenge | +--------------+--------------+-------------+ ChallengeResponse +--------------+--------------+-------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+-------------+ | 16 | U8 | response | +--------------+--------------+-------------+ SecurityResult 客户端选择认证方式后，服务端返回 SecurityResult 告知认证结果，哪怕使用 None 认证。 如果认证失败，服务器发送 failed 和 fail-reason 报文，主动关闭连接。 +--------------+--------------+-------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+-------------+ | 4 | U32 | status: | | | 0 | OK | | | 1 | failed | +--------------+--------------+-------------+ Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"handshake/initial.html":{"url":"handshake/initial.html","title":"初始化","keywords":"","body":"初始化 收 SecurityResult 后，客户端应当发送 ClientInit 数据包，收到后，服务端发送 ServerInit 包。 sequenceDiagram participant Client participant Server Server->>Client: SecurityResult(success) Client->>Server: ClientInit Server->>Client: ServerInit 客户端初始化 客户端初始化需要声明是否的共享屏幕。 +--------------+--------------+-------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+-------------+ | 1 | U8 | shared-flag | +--------------+--------------+-------------+ shared-flag: 是否与其他客户端共享连接。如果是 1，允许服务端保持/加入其他客户端的连接。如果是0，服务端应该主动断开与其他客户端的连接。 服务端初始化 收到 ClientInit 消息后，服务端发送 ServerInit 消息，声明帧缓冲区大小、像素格式以及桌面的名称。 +--------------+--------------+------------------------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+------------------------------+ | 2 | U16 | framebuffer-width in pixels | | 2 | U16 | framebuffer-height in pixels | | 16 | PIXEL_FORMAT | server-pixel-format | | 4 | U32 | name-length | | name-length | U8 array | name-string | +--------------+--------------+------------------------------+ framebuffer-width in pixels: 屏幕宽度 framebuffer-height in pixels: 屏幕高度 server-pixel-format: 服务器默认像素格式 name-length/name-string: 桌面的名字 如果客户端无法响应服务端指定的 pixel-format，可以主动发起 SetPixelFormat 重新设置。 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/":{"url":"transfer/","title":"数据交互","keywords":"","body":"数据交互 数据交互阶段，客户端向服务端发送鼠标、键盘事件，或请求更新图像。 graph LR A(\"鼠标事件\") B(\"键盘事件\") C(\"更新图像\") Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/display.html":{"url":"transfer/display.html","title":"显示协议","keywords":"","body":"显示协议 客户端可能处于弱网络环境，或只有较低性能的渲染设备。如果服务端不加限制的向客户端发送像素画面，很容易造成客户端卡死或网络堵塞。 在 RFB 协议中，当且仅当客户端主动请求显示数据时，服务端才会将 FramebufferUpdate 发往客户端。响应 FramebufferUpdateRequest 往往需要返回多条 FramebufferUpdate。 sequenceDiagram participant Client participant Server Client->>Server: FramebufferUpdateRequest loop no change Client->>Server: FramebufferUpdateRequest end Server->>Client: FramebufferUpdate Server->>Client: FramebufferUpdate Server->>Client: FramebufferUpdate FramebufferUpdateRequest FramebufferUpdateRequest 告知服务端，客户端希望得到指定区域的内容。 +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U8 [3] | message-type | | 1 | U8 | incremental | | 2 | U16 | x-position | | 2 | U16 | y-position | | 2 | U16 | width | | 2 | U16 | height | +--------------+--------------+--------------+ message-type: 消息类型，固定 3 incremental: 是否是增量请求。 x-position/y-position: 区域的起始坐标 width/height: 区域的长度和宽度 incremental 通常为非 0 值，服务器只需要发有变化的图像信息。当客户端丢失了缓存的帧缓冲信息，或者刚建立连接，需要完整的图像信息时，将 incremental 置为 0，获取全量信息。 FramebufferUpdate FramebufferUpdate 由一组矩形图像(rectangles of pixel)组成，客户端收到 FramebufferUpdate 消息后，将消息内的矩形填充到帧缓冲对应区域，完成图像展示。 +--------------+--------------+----------------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+----------------------+ | 1 | U8 [0] | message-type | | 1 | | padding | | 2 | U16 | number-of-rectangles | +--------------+--------------+----------------------+ message-type: 消息类型，固定 0 number-of-rectangles: 矩形的数量 FramebufferUpdateRectangle FramebufferUpdate 携带 number-of-rectangles 数量的矩形信息，每个矩形都有头部信息 +--------------+--------------+---------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+---------------+ | 2 | U16 | x-position | | 2 | U16 | y-position | | 2 | U16 | width | | 2 | U16 | height | | 4 | S32 | encoding-type | +--------------+--------------+---------------+ x-position/y-position: 矩形起始坐标 width/height: 矩形宽度和高度 encoding-type: 编码类型 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/pixel-format.html":{"url":"transfer/pixel-format.html","title":"像素格式","keywords":"","body":"像素格式 帧缓冲由像素构成。 PixelFormat RFB 协议中，使用 16 字节结构体 PIXEL_FORMAT 描述像素的格式。 +--------------+--------------+-----------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+-----------------+ | 1 | U8 | bits-per-pixel | | 1 | U8 | depth | | 1 | U8 | big-endian-flag | | 1 | U8 | true-color-flag | | 2 | U16 | red-max | | 2 | U16 | green-max | | 2 | U16 | blue-max | | 1 | U8 | red-shift | | 1 | U8 | green-shift | | 1 | U8 | blue-shift | | 3 | | padding | +--------------+--------------+-----------------+ bits-per-pixel: 像素的位数，位数越大，色彩越丰富。只支持[8|16|32] depth: 色深，像素中表示色彩的位数 big-endian-flag: 多字节像素的字节序，非零即大端序 true-color-flag: 1 表示真彩色，pixel 的值表示 RGB 颜色；0 表示调色板，pexel 的值表示颜色在调色板的偏移量 -max/-shift: 获取红蓝绿三色的位移量和长度，max=2^N-1,N是颜色的位数 BigEndian: Blue Shift Green Shift Red Shift │ │ │ ▼ ▼ ▼ ┌──────────────────┬─────────────────┬─────────────────┐ │ BLUE MAX │ GREEN MAX │ RED MAX │ └──────────────────┴─────────────────┴─────────────────┘ bits-per-pixel 必须大于或等于 depth SetPixelFormat 客户端发送 SetPixelFormat，声明需要的的像素格式（画面质量）。此消息覆盖 ServerInit 消息中服务端声明的初始化像素格式。 当 true-color-flag 为 0 时，服务端必须发送 SetColorMapEntries，声明使用的颜色表。客户端发送 SetPixelFormat 后，需清空本地缓存的颜色表，无论颜色表中是否有内容。 +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U8 [0] | message-type | | 3 | | padding | | 16 | PIXEL_FORMAT | pixel-format | +--------------+--------------+--------------+ message-type: 消息类型，固定为 0 pixel-format: PixelFormat 结构 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/input/":{"url":"transfer/input/","title":"输入协议","keywords":"","body":"输入协议 RFB 协议支持鼠标和键盘两种输入设备，同时支持剪贴板进行远程复制粘贴。 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/input/mouse.html":{"url":"transfer/input/mouse.html","title":"鼠标事件","keywords":"","body":"鼠标事件 鼠标指针即鼠标操作事件，分移动事件和点击事件两种。在 RFB 协议中，使用 PointerEvent 表示客户端触发一次鼠标事件。 协议报文 鼠标事件的报文如下 +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U8 [5] | message-type | | 1 | U8 | button-mask | | 2 | U16 | x-position | | 2 | U16 | y-position | +--------------+--------------+--------------+ message-type: 无符号整形，固定 0x5 button-mask: 8 位掩码，表示键位状态，1为按下，0为弹起 x-position: 当前 X 坐标 y-position: 当前 Y 坐标 button-mask 的 Bit0/1/2 位置分别代表鼠标的左键、中建、右键。使用滚轮的鼠标，每向上滑动一次，会发送一个 Bit3 的按下和弹起事件；每向下滑动一次，会发送一个 Bit4 的按下和弹起事件。 USB/PS/2 鼠标协议 在 PS/2 或 USB 鼠标协议中，有类似 RFB 协议的表达方式。 ┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐ │ │ Bit7 │ Bit6 │ Bit5 │ Bit4 │ Bit3 │ Bit2 │ Bit1 │ Bit0 │ ├──────┼──────┼──────┼──────┼──────┼──────┼──────┼──────┼──────┤ │Byte 1│Y Over│X Over│X Sign│Y Sign│ 0x1 │ Mid │Right │ Left │ ├──────┼──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┤ │Byte 2│ X Movement │ ├──────┼───────────────────────────────────────────────────────┤ │Byte 3│ Y Movement │ ├──────┼───────────────────────────────────────────────────────┤ │Byte 4│ Z Movement │ └──────┴───────────────────────────────────────────────────────┘ 鼠标协议和 RFB 协议有两点不同： 鼠标协议的 Bit0/1/2 和 RFB 协议的 Bit0/2/1 对应 鼠标协议的中轮转动，需要转换为 RFB 协议的按下/弹起事件 根据 wiki 描述，RFB 协议只支持8个鼠标键位，左中右和滑轮占用5个，只有3个键位给特殊按键（例如：多功能游戏鼠标） Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/input/keyboard.html":{"url":"transfer/input/keyboard.html","title":"键盘事件","keywords":"","body":"键盘事件 在正常理解中，键盘事件的处理应该是简单明了的。参考以下协议报文 +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U8 [4] | message-type | | 1 | U8 | down-flag | | 2 | | padding | | 4 | U32 | key | +--------------+--------------+--------------+ message-type: 固定为 0x4 down-flag: 1 表示键位按下，0 表示弹起 pending: 对齐字节，方便解析 key: 表示具体的键位 其中 key 的值在 X 系统中有明确定义 +-----------------+--------------------+ | Key name | Keysym value (hex) | +-----------------+--------------------+ | BackSpace | 0xff08 | | Tab | 0xff09 | | Return or Enter | 0xff0d | | Escape | 0xff1b | | Insert | 0xff63 | | Delete | 0xffff | | Home | 0xff50 | | End | 0xff57 | | Page Up | 0xff55 | | Page Down | 0xff56 | | Left | 0xff51 | | Up | 0xff52 | | Right | 0xff53 | | Down | 0xff54 | | F1 | 0xffbe | | F2 | 0xffbf | | F3 | 0xffc0 | | F4 | 0xffc1 | | ... | ... | | F12 | 0xffc9 | | Shift (left) | 0xffe1 | | Shift (right) | 0xffe2 | | Control (left) | 0xffe3 | | Control (right) | 0xffe4 | | Meta (left) | 0xffe7 | | Meta (right) | 0xffe8 | | Alt (left) | 0xffe9 | | Alt (right) | 0xffea | +-----------------+--------------------+ 组合键 组合键指 Ctrl + Alt + Del 或 Shift + 3 等组合按键。受不同的操作系统、键盘布局影响，组合键是按键事件中容易发生歧义的一环。 RFB 基本遵循以下规则： 如果客户端 key 在 keysym 中存在，服务端应该遵循 keysym 的指示，尽可能的忽略客户端传递 Shift、CpasLock 等键位，在需要时，应该主动补充/忽略 Shift 等键位。例如，在 US 键盘布局中，# 需要按下 Shift + 3，但是在 UK 布局中不需要。这就意味着用户在输入 # 的时候不会输入 Shift。这种情况下，服务端应该主动模拟一个 Shift 状态，防止输入的键位是 3。同理，如果 key 输入的键位是 A，服务端统一要模拟一个 Shift，保证输入的是 A 而不是 a。 如果客户端 key 在 keysym 中不存在（例如 Ctrl + A），服务端应该遵循客户端指示，客户端应该主动在 A 前发送 Ctrl 的按键。 如果客户端通过 Ctrl + Alt + Q 来输入 @，客户端应该在发送 Ctrl/Alt/@后，主动发送Ctrl/Alt的弹起事件。 对于 BackTab，常见的有三种实现，ISO_Left_Tab BackTab 和 Shift + Tab。RFB 协议优先使用 Shift + Tab，但对于其他的键位，服务端和客户端应当尽量提供兼容。 优先使用 ASCII 而不是 unicode 对于 Ctrl + Alt + Del 等无法被客户端操作系统拦截的按键（系统拦截有更高优先级），客户端应该提供操作按钮 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/input/clipboard.html":{"url":"transfer/input/clipboard.html","title":"剪贴板","keywords":"","body":"剪贴板 复制粘贴是双向事件，可以由客户端向服务端复制，也可以由服务端向客户端复制。 协议报文 复制剪贴板的报文如下： +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U8 [3/6] | message-type | | 3 | | padding | | 4 | U32 | length | | length | U8 array | text | +--------------+--------------+--------------+ message-type: 消息类型，客户端是 0x6，服务端是 0x3 length: 文本长度 text: 复制粘贴的文本，长度由 length 限制 协议有几点限制 只支持 ISO 8859-1 (Latin-1) 字符集 使用单独换行符 0x0a，不应该使用回车符 0x0d 拓展剪贴板伪协议 RFB 3.8 协议限制，剪贴板只能传输 Latin-1 字符集。 2016年，Cendio Ossman 将 Extended Clipboard Pseudo-Encoding 合入协议主分支，支持在剪贴板消息中传输 unicode 字符集。 UltraVNC/TigerVNC/RealVNC 服务端都支持此拓展协议，x11vnc 尚未提供支持（2021/8/11）。 拓展剪贴板伪协议需要客户端和服务端软件同时支持。报文拓展了 ServerCutText 和 ClientCutText， 如下： +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U8 [3/6] | message-type | | 3 | | padding | | 4 | S32 | length | | 4 | U32 | text-type | | length-4 | U8 array | text | +--------------+--------------+--------------+ length: 数据由 U32 改为 S32。首bit是标志位，0 表示传递原始 Latin-1 消息，1 表示传递拓展信息。abs(length) 是实际的消息长度。 text-type: 消息头部，指示消息类型 text: 消息内容 消息类型 消息用 4 字节的 text-type 作为头部。 +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U32 | message-type | +--------------+--------------+--------------+ text-type 分为指令（action）和格式（formats）两类。指令传输操作命令，格式传输剪贴板内容。 text-type 标记的含义如下： Bit Name Description 0 text 文本内容 1 rtf 微软富文本格式 2 html 微软 HTML 格式 3 dib Microsoft Device Independent Bitmap 4 files 文件，暂未实现 5-15 fotmats 保留位 16-23 保留 24 caps 指示支持的 text-type 和最大长度 25 request 强制对端传递剪贴板内容 26 peek 强制对端提供支持的 text-type 27 notify peek 回包，返回支持的 text-type 28 provide request 回包，返回粘贴板内容 29-31 actions 保留位 文本内容 text 纯文本，unicode 编码的无格式文本。以 \\r\\n 作为行的结尾，原始协议的换行符是 \\n。 文本应该以 \\0 结尾，即使在 ClientCutText/ServerCutText 中都声明了文本长度。 能力声明 caps Caps 指示期望收到的文本类型，发送的结构是长度数组。数组大小跟格式数量相等（0-15），数组的每个条目，指示格式支持的最大长度。 数据结构 +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | formats*4 | U32 array | sizes | +--------------+--------------+--------------+ 例如： [1024,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 表示只接受 1024 byte 以内的纯文本信息。 行为约束 服务端收到支持拓展剪贴板协议的 SetEncodings 报文时，必须主动发送类型为 caps 的 ServerCutText 消息。 客户端收到 caps 消息时，应该发送类型为 caps 的 ClientCutText 消息作为回应。 否则，客户端默认会接受 text/rtf/html/request/notify/provide 消息，其中 text 默认长度为 20 Mib，其他为 0 字节。 当最大长度限制为 0 时，认为长度没有限制，如果内容长度大于声明的长度限制，则剪贴板变动的消息不会被发送。建议将所有的 caps 设置为 0，以便接受所有的剪贴板消息变动。 某些实现的默认行为与协议描述不一致，例如： dib 也是默认支持的格式 text 的默认限制是 10Mid rft/html 默认限制为 2Mib dib 默认限制为 0 字节 客户端忽略 caps 消息建议的格式和长度限制 在发送 caps 之前，只能发送指令，不能发送格式和内容。 粘贴板内容 粘贴板内容的 text-type 是 provide。在剪贴板变化，或对端发送 request 后发送。 在 text-type 后面，是 Zlib 压缩的字节流。对于每种支持的 text-type，会发送 size + data 数据对。 +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 4 | U32 | size | | size | U8 array | data | +--------------+--------------+--------------+ Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/encoding/":{"url":"transfer/encoding/","title":"编码","keywords":"","body":"编码 ”编码“ 是像素数据的表达方式。在发往客户端前，服务器经常将发送的图形数据进行编码、压缩，提高图像传输效率。 +--------+-----------------------------+ | Number | Name | +--------+-----------------------------+ | 0 | Raw | | 1 | CopyRect | | 2 | RRE | | 5 | Hextile | | 15 | TRLE | | 16 | ZRLE | | -239 | Cursor pseudo-encoding | | -223 | DesktopSize pseudo-encoding | +--------+-----------------------------+ Raw: 原始位图编码，即不编码 CopyRect: 从帧缓冲复制 RRE: rise-and-run-length 二维游程编码 Hextile: RRE 的变种，图块游程编码 TRLE: 图块游程编码 ZRLE: Zlib Run-Length Encoding，zlib 压缩的游程编码 Cursor pseudo-encoding: 鼠标指针伪编码 DesktopSize pseudo-encoding: 桌面分辨率伪编码 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/encoding/set-encoding.html":{"url":"transfer/encoding/set-encoding.html","title":"设置编码","keywords":"","body":"设置编码 客户端用 SetEncoding 消息告知服务端，接受哪些像素编码。 除了用于解析像素的编码外，客户端可以发送伪编码，向服务端请求拓展功能。如果服务端不识别此编码，可以直接忽略。客户端在未收到服务端明确的”支持“回复前，应当默认服务端不支持伪编码。 数据结构如下： +-----------------------+--------------+---------------------+ | No. of bytes | Type [Value] | Description | +-----------------------+--------------+---------------------+ | 1 | U8 [2] | message-type | | 1 | | padding | | 2 | U16 | number-of-encodings | | 4*number-of-encodings | S32 array | encoding-types | +-----------------------+--------------+---------------------+ message-type: 消息类型，固定为 2 number-of-encodings: 编码数量 encoding-types: 编码标识符 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/encoding/raw.html":{"url":"transfer/encoding/raw.html","title":"Raw 原始编码","keywords":"","body":"Raw 原始编码 Raw 是最简单也是最原始的编码，直接向客户端传递位图信息，不进行编码优化。 在 Raw 格式中，像素按从左到右，从上到下的顺序排列成一维数组。 协议要求客户端必须支持 Raw 类型编码。 协议要求服务器必须传输 Raw 类型编码，除非客户端另有要求。 +----------------------------+--------------+-------------+ | No. of bytes | Type [Value] | Description | +----------------------------+--------------+-------------+ | width*height*bytesPerPixel | PIXEL array | pixels | +----------------------------+--------------+-------------+ pixels: 像素数组 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/encoding/copy-rect.html":{"url":"transfer/encoding/copy-rect.html","title":"CopyRect 镜像编码","keywords":"","body":"镜像编码 Copy Rect CopyRect 指示客户端，从已有帧缓冲区域复制到新区域。这种编码常用于窗口拖动、页面滚动等场景。 报文只说明起始坐标，区域的长度和宽度由 FramebufferUpdateRectangle 指定。 +--------------+--------------+----------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+----------------+ | 2 | U16 | src-x-position | | 2 | U16 | src-y-position | +--------------+--------------+----------------+ src-x-position/src-y-position: 源图像的起点坐标 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/encoding/rise-and-run-length.html":{"url":"transfer/encoding/rise-and-run-length.html","title":"RRE 上升游程编码","keywords":"","body":"上升和游程编码 Rise-and-run-length RRE 是游程编码的二维变种。基本思想是将大的矩形拆分为子矩形，每个子矩形有单值的像素组成，所有小矩形的并集构成原始矩形区域。 编码由背景像素值 Vb 、计数 N ，以及 N 个子矩形列表组成。子矩形由元组 表示，其中 v 是像素值（v != Vb），x/y/w/h 表示子矩形相对主矩形的坐标，和大小。 绘制时，客户端先以背景像素值填充矩形，再绘制每个子矩形，叠加出原始图像。 +---------------+--------------+-------------------------+ | No. of bytes | Type [Value] | Description | +---------------+--------------+-------------------------+ | 4 | U32 | number-of-subrectangles | | bytesPerPixel | PIXEL | background-pixel-value | +---------------+--------------+-------------------------+ number-of-subrectangles: 子矩形数量 background-pixel-value: 矩形背景色 对于子矩形 +---------------+--------------+---------------------+ | No. of bytes | Type [Value] | Description | +---------------+--------------+---------------------+ | bytesPerPixel | PIXEL | subrect-pixel-value | | 2 | U16 | x-position | | 2 | U16 | y-position | | 2 | U16 | width | | 2 | U16 | height | +---------------+--------------+---------------------+ subrect-pixel-value: 子矩形色值 x-position/y-position: 与背景矩行的相对位置 width/height: 子矩形宽度和高度 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/encoding/tiled-run-length.html":{"url":"transfer/encoding/tiled-run-length.html","title":"TRLE 图块游程编码","keywords":"","body":"图块游程编码 TRLE TRLE（Tiled Run-Length Encoding），使用图块压缩技术、调色板技术以及游程编码，对传输的桌面图像进行压缩。 在图块压缩技术中，传输图像被分为 N 个 16x16 的小图块，图块按从左到右，从上到下的顺序排列成一位数组。如果传输图像的尺寸不是 16 的整数倍，最后一列/最后一行图块的宽度/高度应为实际宽度/实际高度（小于16）。 TRLE 使用 CPIXEL(compressed pixel) 表示像素。CPIXEL 同样由 PIXEL_FORMAT 定义。 在特殊情况下，CPIXEL 使用更紧凑的结构表示像素。 假如 PIXEL_FORMAT 中 true-color-flag 是非零值，bits-per-pixel 是 32，depth 是 24 或更小，只会用低 3 bit 或者高 3 bit 来表达红、绿、蓝。 子编码 图块使用头部单字节表示图块的子编码类型。 子编码类型的最高比特表示当前图块是否使用游程编码。 低 7-bit 指示调色板的大小。 +---------------+--------------+------------------+ | No. of bits | Type [Value] | Description | +------------------------------+------------------+ | 1 | bit | run-length-flag | | 2-8 | bit | palette-length | +------------------------------+------------------+ TRLE 对自编码的值有单独定义 十六进制 十进制 含义 0x00 0 Raw 模式，不使用游程和调色板 0x01 1 纯色模式，图块使用同一种颜色 0x02 - 0x10 2 - 16 打包像素调色板模式 0x11 - 0x7E 17 - 126 保留 0x7F 127 打包像素调色板模式，复用调色板 0x80 128 RLE 模式 0x81 129 调色板游程编码，复用调色板 0x82 - 0xFF 130 - 255 调色板游程编码 Raw 模式 Raw 模式直接传输像素值，像素在图块中按从左到右、从上到下排列。不使用游程编码，不使用调色板。 +-----------------------------+----------------+--------------+ | No. of bytes | Type [Value] | Description | +-----------------------------+----------------+--------------+ | 1 | SubEncoding[0] | sub-encoding | | width*height*BytesPerCPixel | CPIXEL array | pixels | +-----------------------------+----------------+--------------+ 纯色模式 图块使用同一种颜色。 +----------------+----------------+--------------+ | No. of bytes | Type [Value] | Description | +----------------+----------------+--------------+ | 1 | SubEncoding[1] | sub-encoding | | bytesPerCPixel | CPIXEL | pixelValue | +----------------+----------------+--------------+ 打包像素调色板模式 打包像素调色板模式。使用调色板定义颜色，使用颜色在调色板中的偏移量表达颜色。由于调色板较小，可以将多个像素的色值打包到一个字节中存储，进一步压缩体积。 每个像素使用的 bit 数由调色板大小确定，N=log2 M。 如果像素的数量不是 2/4/8 的倍数，需要添加填充位，对齐字节。 调色板大小 像素比特数 打包后字节数 =2 1 m = (width+7) // 8 *height 2 m = (width+3) // 4 * height 4 m = (width+1) // 2 * height +----------------------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +----------------------------+--------------+--------------+ | 1 | SubEncoding | sub-encoding | | paletteSize*bytesPerCPixel | CPIXEL array | palette | | m | U8 array | packedPixels | +----------------------------+--------------+--------------+ RLE 模式 RLE 模式，不使用调色板，使用游程编码。在计算游程时，允许跨行计算。 长度由一个或多个字节表示，到第一个不是 255（0xFF）停止。 +-------------------------+------------------+-----------------------+ | No. of bytes | Type [Value] | Description | +-------------------------+------------------+-----------------------+ | 1 | SubEncoding[128] | sub-encoding | | bytesPerCPixel | CPIXEL | pixelValue | | div(runLength - 1, 255) | U8 array | 255 | | 1 | U8 | (runLength-1) mod 255 | +-------------------------+------------------+-----------------------+ 例如： 游程长度 字节表示 1 0x00 255 0xFE 256 0xFF00 257 0xFF01 510 0xFFFE 511 0xFFFF00 调色板游程编码 调色板游程编码。使用调色板，游程部分类似RLE 模式，将像素放入数组后，使用像素加游程的方式表示整个色块，像素用调色板偏移量表示。 +----------------------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +----------------------------+--------------+--------------+ | 1 | SubEncoding | sub-encoding | | paletteSize*bytesPerCPixel | CPIXEL array | palette | +----------------------------+--------------+--------------+ 长度为1的游程，仅由调色板索引表示 +--------------+--------------+--------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+--------------+ | 1 | U8 | paletteIndex | +--------------+--------------+--------------+ 长度大于1的游程，由调色板索引+128和游程长度表示 +-------------------------+--------------+-----------------------+ | No. of bytes | Type [Value] | Description | +-------------------------+--------------+-----------------------+ | 1 | U8 | paletteIndex + 128 | | div(runLength - 1, 255) | U8 array | 255 | | 1 | U8 | (runLength-1) mod 255 | +-------------------------+--------------+-----------------------+ Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "},"transfer/encoding/zlib-run-length.html":{"url":"transfer/encoding/zlib-run-length.html","title":"ZRLE Zlib游程编码","keywords":"","body":"zlib 压缩游程编码 ZRLE 融合游程编码、Zlib 压缩算法、图块压缩算法对传输图像进行压缩。 ZRLE 使用 Zlib 进行编码和解码，要求流数据严格有序。 +--------------+--------------+-------------+ | No. of bytes | Type [Value] | Description | +--------------+--------------+-------------+ | 4 | U32 | length | | length | U8 array | zlibData | +--------------+--------------+-------------+ length: 流(stream)长度 zlibData: 流数据 ZlibData 解压后，是从左到右，从上到下排列的图块数据。图块大小是 64x64，其他跟 TRLE 一致。对于长度和宽度不足的图形，其最后一排和最后一列的宽/高是实际尺寸，不做补齐。 Copyright © Vincent.H.Cui 2021 all right reserved，powered by Gitbook最后更新： 2021-08-16 12:01 "}}